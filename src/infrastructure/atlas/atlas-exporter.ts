import type { PackedAtlas } from "@/src/domain/types/atlas";

export function exportToJsonArray(atlas: PackedAtlas, name: string): string {
  const frames = atlas.frames.map((frame) => ({
    filename: frame.name,
    frame: { x: frame.x, y: frame.y, w: frame.width, h: frame.height },
    rotated: frame.rotated,
    trimmed: frame.trimmed,
    spriteSourceSize: frame.spriteSourceSize,
    sourceSize: frame.sourceSize,
  }));

  return JSON.stringify(
    {
      frames,
      meta: {
        app: "Game Asset Tool",
        version: "1.0",
        image: `${name}.png`,
        format: "RGBA8888",
        size: { w: atlas.width, h: atlas.height },
        scale: "1",
      },
    },
    null,
    2
  );
}

export function exportToJsonHash(atlas: PackedAtlas, name: string): string {
  const frames: Record<string, object> = {};

  atlas.frames.forEach((frame) => {
    frames[frame.name] = {
      frame: { x: frame.x, y: frame.y, w: frame.width, h: frame.height },
      rotated: frame.rotated,
      trimmed: frame.trimmed,
      spriteSourceSize: frame.spriteSourceSize,
      sourceSize: frame.sourceSize,
    };
  });

  return JSON.stringify(
    {
      frames,
      meta: {
        app: "Game Asset Tool",
        version: "1.0",
        image: `${name}.png`,
        format: "RGBA8888",
        size: { w: atlas.width, h: atlas.height },
        scale: "1",
      },
    },
    null,
    2
  );
}

export function exportToCocos(atlas: PackedAtlas, name: string): string {
  let plist = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>frames</key>
    <dict>
`;

  atlas.frames.forEach((frame) => {
    plist += `        <key>${frame.name}</key>
        <dict>
            <key>frame</key>
            <string>{{${frame.x},${frame.y}},{${frame.width},${frame.height}}}</string>
            <key>offset</key>
            <string>{0,0}</string>
            <key>rotated</key>
            <${frame.rotated}/>
            <key>sourceColorRect</key>
            <string>{{0,0},{${frame.width},${frame.height}}}</string>
            <key>sourceSize</key>
            <string>{${frame.width},${frame.height}}</string>
        </dict>
`;
  });

  plist += `    </dict>
    <key>metadata</key>
    <dict>
        <key>format</key>
        <integer>2</integer>
        <key>realTextureFileName</key>
        <string>${name}.png</string>
        <key>size</key>
        <string>{${atlas.width},${atlas.height}}</string>
        <key>textureFileName</key>
        <string>${name}.png</string>
    </dict>
</dict>
</plist>`;

  return plist;
}

export function exportToPhaser(atlas: PackedAtlas, name: string): string {
  const frames = atlas.frames.map((frame) => ({
    filename: frame.name,
    frame: { x: frame.x, y: frame.y, w: frame.width, h: frame.height },
    rotated: frame.rotated,
    trimmed: frame.trimmed,
    spriteSourceSize: { x: 0, y: 0, w: frame.width, h: frame.height },
    sourceSize: { w: frame.width, h: frame.height },
  }));

  return JSON.stringify(
    {
      textures: [
        {
          image: `${name}.png`,
          format: "RGBA8888",
          size: { w: atlas.width, h: atlas.height },
          scale: 1,
          frames,
        },
      ],
      meta: {
        app: "Game Asset Tool",
        version: "1.0",
      },
    },
    null,
    2
  );
}

export function exportToUnity(atlas: PackedAtlas, name: string): string {
  const sprites = atlas.frames.map((frame) => ({
    name: frame.name.replace(/\.[^/.]+$/, ""),
    rect: { x: frame.x, y: frame.y, width: frame.width, height: frame.height },
    pivot: { x: 0.5, y: 0.5 },
    border: { x: 0, y: 0, z: 0, w: 0 },
  }));

  return JSON.stringify(
    {
      textureFileName: `${name}.png`,
      textureWidth: atlas.width,
      textureHeight: atlas.height,
      sprites,
    },
    null,
    2
  );
}

export function exportToCSS(atlas: PackedAtlas, name: string): string {
  let css = `/* Generated by Game Asset Tool */
.sprite {
  background-image: url('${name}.png');
  background-repeat: no-repeat;
  display: inline-block;
}

`;

  atlas.frames.forEach((frame) => {
    const className = frame.name
      .replace(/\.[^/.]+$/, "")
      .replace(/[^a-zA-Z0-9]/g, "-")
      .toLowerCase();

    css += `.sprite-${className} {
  width: ${frame.width}px;
  height: ${frame.height}px;
  background-position: -${frame.x}px -${frame.y}px;
}

`;
  });

  return css;
}

export async function renderAtlasToCanvas(
  atlas: PackedAtlas
): Promise<HTMLCanvasElement> {
  const canvas = document.createElement("canvas");
  canvas.width = atlas.width;
  canvas.height = atlas.height;
  const ctx = canvas.getContext("2d");

  if (!ctx) {
    throw new Error("Could not get canvas context");
  }

  ctx.clearRect(0, 0, atlas.width, atlas.height);

  for (const frame of atlas.frames) {
    if (frame.image) {
      ctx.drawImage(frame.image, frame.x, frame.y, frame.width, frame.height);
    }
  }

  return canvas;
}

export function downloadFile(
  content: string,
  filename: string,
  mimeType: string
): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function downloadCanvas(
  canvas: HTMLCanvasElement,
  filename: string
): void {
  const url = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
